---
layout: post
title: "Lerping Every Frame: What Curve Does It Represent?"
published: false
---

## Conclusion

TODO

Lerp is an exponential.

Lerp is frame rate dependent, but only very slightly so. Just make sure to multiply the factor by the time elapsed since the last frame.

## Lerp

In games, code is run each frame to update the game state, then the result is rendered and flashed on the player's screen for a fraction of a second - until the next frame is ready to be displayed.

I am working on player movement in Unity (a game engine), and want the player's velocity to change smoothly from frame to frame - with no abrupt speed changes.

Naturally, I decide to use $$lerp$$ to this effect:

$$ lerp(a, b, d) = a + d \cdot (b - a)  $$

This function, very commonly used in game development, moves a value $$a$$ towards a value $$b$$ by a factor $$d \in [0, 1]$$. It can be used to animate an object's position, rotation, color, and almost anything else.

Because it is so common and accessible, I want to know what the underlying animation curve is when it is used over multiple frames. Additionally, I worry that framerate may have an effect on that curve, and want to prevent that from happening as it can result in different gameplay for players with varying framerates.

## The Curve

If we run $$lerp$$ each frame with constant $$a$$ and $$b$$ while making $$d$$ equal to the time elapsed, the result is a simple line that reaches the target value after one second:

<iframe src="https://www.desmos.com/calculator/3vklex2bg7" width="800" height="450" style="border: 1px solid #ccc" frameborder=0></iframe>

But this is quite rarely done. To study an actually curvy example, we assign the result of $$lerp$$ to $$a$$ on each frame, and set the factor $$d$$ to a small constant.

In an effort to make the curve less dependent on framerate, we make $$d$$ a multiple of the time in seconds between each frame $$ \Delta time $$. For simplicity, we make $$ d = 1 \Delta time $$[^1].

[^1]: We ignore the case where $$ d \notin [0, 1] $$, as the value can simply be clamped to that range.

To make things even simpler, we can set $$a = 0$$ and $$b = 1$$, which does not affect the underlying animation curve.

We can then define the iterative $$lerp$$ as a series $$S$$ given a frame number $$n$$:

$$
S_{0} = 0
$$

$$
S_{n} = S_{n-1} + d \cdot (1 - S_{n-1})
$$

Each frame, we take the previous frame's result and add to it the remaining value multiplied by $$d$$.

Now, if we manage to convert this series to a continuous function, it should tell us
what the underlying curve is.

Sadly, there is no simple way to convert a discrete function to a continuous one, much less a recursive series. One has to look at the result and try to infer a compatible continuous expression.

Something that would make this process much easier would be to remove the recursivity
We can make one change to make this process easier

asdklfj


Where we take last frame's value $$S_{n-1}$$ and add to it the remaining

## Something else

I tried approaching it from an ascending perspective, with

$$
a(0) = 0
a(n) = a(n-1) + d(1 - a(n - 1))
$$

But it is easier if we lerp from 1 to 0, with

$$ a(n) = (1 - d)^n $$

---

{:footnotes}
